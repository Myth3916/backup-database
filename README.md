# Домашнее задание: Резервное копирование баз данных - Шаров Олег

## Задание 1. Резервное копирование

### Кейс
Финансовая компания решила увеличить надёжность работы баз данных и их резервного копирования.

### Ответы

#### 1.1. Восстановление данных в полном объёме за предыдущий день

**Решение:** Ежедневное полное резервное копирование (Full Backup).

**Обоснование:**
- Каждую ночь (например, в 02:00) выполняется полная копия всей базы данных.
- При поломке утром достаточно восстановить один файл бэкапа за предыдущие сутки.
- Простота восстановления: не требуется цепочка файлов, как при инкрементном/дифференциальном подходе.

**Пример команды (PostgreSQL):**
```bash
pg_dump -U postgres finance_db > /backup/finance_db_$(date +%F).sql
```

#### 1.2. Восстановление данных за час до предполагаемой поломки
**Решение** : PITR (Point-in-Time Recovery) на основе:
1. Базового полного бэкапа
2. Непрерывной архивации логов транзакций (WAL для PostgreSQL, binlog для MySQL)
**Обоснование** :
- Полный бэкап создаётся раз в сутки (базовая точка).
- Логи транзакций архивируются непрерывно (каждые несколько секунд/минут).
- При восстановлении можно указать точное время (например, 2026-02-19 09:00:00), чтобы вернуть состояние БД на час до поломки.
- Минимизирует потерю данных — критично для финансовых систем.
**Пример настройки WAL-архивации (PostgreSQL)** :

```ini
# postgresql.conf
archive_mode = on
archive_command = 'cp %p /backup/wal/%f'
```

---

## Задание 2. PostgreSQL

### 2.1. Примеры команд резервного копирования и восстановления

#### Вариант 1: Формат Plain SQL (текстовый)

**Создание бэкапа:**
```bash
pg_dump -U postgres finance_db > finance_db_$(date +%F).sql
```
**Восстановление**:

```bash
# Создаём пустую БД
createdb -U postgres finance_db_restored

# Восстанавливаем данные
psql -U postgres -d finance_db_restored < finance_db_2026-02-19.sql
```

**Пояснение**:

- `>` — перенаправление вывода в файл
- `date +%F` — автоматическая дата в имени файла (формат: `2026-02-19`)
- `<` — подача файла на вход `psql`


**Вариант 2: Формат Custom (бинарный, сжатый)**

**Создание бэкапа** :

```bash
pg_dump -U postgres -Fc finance_db > finance_db_$(date +%F).dump
```

**Восстановление** :

```bash
# Создаём пустую БД
createdb -U postgres finance_db_restored

# Восстанавливаем данные
pg_restore -U postgres -d finance_db_restored finance_db_2026-02-19.dump
```

**Пояснение** :

- `-Fc` — формат Custom (сжатый)
- `pg_restore` — утилита для восстановления бинарных бэкапов
- Возможность восстановить отдельные таблицы:
`pg_restore -U postgres -d finance_db_restored -t users finance_db_2026-02-19.dump`


### Краткая таблица команд

| Операция | Формат | Команда |
|----------|--------|---------|
| **Бэкап** | Plain SQL | `pg_dump -U postgres finance_db > finance_db_$(date +%F).sql` |
| **Восстановление** | Plain SQL | `psql -U postgres -d finance_db_restored < finance_db_2026-02-19.sql` |
| **Бэкап** | Custom (бинарный) | `pg_dump -U postgres -Fc finance_db > finance_db_$(date +%F).dump` |
| **Восстановление** | Custom (бинарный) | `pg_restore -U postgres -d finance_db_restored finance_db_2026-02-19.dump` |


---

## Задание 3. MySQL

### 3.1. Инкрементное резервное копирование

#### Что такое инкрементное резервное копирование в MySQL?

В отличие от полного бэкапа, **инкрементный бэкап** содержит только изменения, произошедшие с момента последнего бэкапа.

В MySQL инкрементное резервное копирование реализуется через **бинарные логи (binlog)** — это журнал всех изменений в базе данных.

**Схема работы:**

Полный бэкап (базовая точка)
↓
Бинарные логи (записываются постоянно)
↓
Инкрементный бэкап = новые записи в binlog


---

#### Шаг 1: Включение бинарных логов

В конфигурационном файле `/etc/mysql/my.cnf` или `/etc/my.cnf`:

```ini
[mysqld]
log-bin = /var/log/mysql/mysql-bin.log
server-id = 1
expire_logs_days = 7
```

**Пояснение** :

- `log-bin` — путь к бинарным логам
- `server-id` — уникальный ID сервера
- `expire_logs_days` — автоматическая очистка старых логов

После изменения перезапустите MySQL:

```bash
sudo systemctl restart mysql
```

**Шаг 2: Полный бэкап (базовая точка)**

```bash
mysqldump -u root -p --single-transaction --flush-logs --master-data=2 finance_db > /backup/finance_db_full_$(date +%F).sql
```

**Пояснение параметров** :

- `--single-transaction` — согласованность бэкапа для InnoDB
- `--flush-logs` — создаёт новый бинарный лог
- `--master-data=2` — записывает позицию бинарного лога в комментарии

**Шаг 3: Инкрементный бэкап**

Инкрементный бэкап = копирование новых бинарных логов:

```bash
# Копируем все бинарные логи
cp /var/log/mysql/mysql-bin.* /backup/binlogs/
```

**Это и есть команда инкрементного резервного копирования.**

**Шаг 4: Восстановление из полного + инкрементного бэкапа**

```bash
# 1. Восстанавливаем полный бэкап
mysql -u root -p finance_db < /backup/finance_db_full_2026-02-19.sql

# 2. Применяем изменения из бинарных логов
mysqlbinlog /backup/binlogs/mysql-bin.000001 | mysql -u root -p
mysqlbinlog /backup/binlogs/mysql-bin.000002 | mysql -u root -p
```

**Пояснение** :

- `mysqlbinlog` — утилита для чтения бинарных логов
- Логи применяются в порядке номеров (000001, 000002, ...)

### Краткий итог
**Инкрементное резервное копирование в MySQL реализуется через бинарные логи (binlog)** :
1. Включить бинарные логи в конфигурации MySQL
2. Сделать полный бэкап с --flush-logs --master-data=2
3. Копировать новые бинарные логи — это и есть инкрементный бэкап
4. Для восстановления: сначала полный бэкап, затем применить бинарные логи через mysqlbinlog

Пример команды инкрементного бэкапа:
```bash
cp /var/log/mysql/mysql-bin.* /backup/binlogs/
```







